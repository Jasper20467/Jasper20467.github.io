<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on Jasper Blog</title>
    <link>/tags/leetcode/</link>
    <description>Recent content in LeetCode on Jasper Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 23 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leet Code Array-PrefixSums</title>
      <link>/post/leetcode-array-prefixsums/</link>
      <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/leetcode-array-prefixsums/</guid>
      <description>Tips: Prefix sum 又可以稱為 cumulative sum 或是 inclusive scan，核心的概念其實蠻直覺簡單，就是將陣列中每個元素的位置上，儲存該位置之前所有元素、或是特定條件下的總和。 const</description>
    </item>
    
    <item>
      <title>Leet Code BFS / DFS</title>
      <link>/post/leetcode-dfs/</link>
      <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/leetcode-dfs/</guid>
      <description>BFS vs. DFS in Flood Fill Algorithm Breadth-First Search (BFS)  Approach:  BFS uses a queue and explores all neighbors at the present depth level before moving on to nodes at the next depth level.   Advantages:  Can be more memory-efficient if the tree/graph is very deep but not very wide. Guarantees the shortest path in an unweighted graph.   Disadvantages:  Can consume more memory if the graph is very wide.</description>
    </item>
    
    <item>
      <title>Leet Code Binary Search</title>
      <link>/post/leetcode-binarysearch/</link>
      <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/leetcode-binarysearch/</guid>
      <description>遞迴和堆疊的關係 在演算法中，使用堆疊（stack）和使用遞迴（recursion）有著密切的關聯，因為遞迴本質上是使用系統堆疊來管理函數調用</description>
    </item>
    
    <item>
      <title>Leet Code BinarySearch Follow up</title>
      <link>/post/leetcode-binarysearch-followup/</link>
      <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/leetcode-binarysearch-followup/</guid>
      <description>LeetCode 110. 平衡二叉樹的後續問題 時間複雜度分析： 你的解決方案的時間複雜度是多少？你能解釋一下為什麼嗎？ 答：時間複雜度是 O(n)，其中 n 是樹中節點的數</description>
    </item>
    
  </channel>
</rss>
